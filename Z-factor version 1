#%% [code]
import numpy as np
from scipy.optimize import fsolve

# =============================================================================
# Component Data Class
# =============================================================================
class ComponentData:
    def __init__(self, components):
        self.data = {
            'Methane':   [190.562, 46.064, 0.011433],
            'Ethane':    [305.406, 48.795, 0.099161],
            'Propane':   [369.901, 42.554, 0.15251],
            'nButane':   [425.817, 38.104, 0.19527],
            'iButane':   [407.776, 36.377, 0.18477],
            'nPentane':  [469.754, 33.684, 0.25056],
            'iPentane':  [460.45,  33.341, 0.22168],
            'C7+':       [540.078, 27.341, 0.34958],
            'C6':        [507.6,   30.3,   0.301],       # New component (e.g., n-Hexane)
            'CO2':       [304.179, 73.821, 0.22551],
            'N2':        [126.207, 33.983, 0.036816],
            'H2S':       [373.25,  89.495, 0.096764]
        }
        self.Mw_data = {
            'Methane':   16.04,
            'Ethane':    30.07,
            'Propane':   44.10,
            'nButane':   58.12,
            'iButane':   58.12,
            'nPentane':  72.15,
            'iPentane':  72.15,
            'C7+':       98.0,
            'C6':        86.18,      # New molecular weight (g/mol) for C6 (n-Hexane)
            'CO2':       44.01,
            'N2':        28.01,
            'H2S':       34.08
        }
        self.components = components


        
    def get_properties(self):
        Tc = []
        Pc = []  # will be converted to Pascals
        wc = []
        for comp in self.components:
            if comp in self.data:
                tc, pc, w = self.data[comp]
                Tc.append(tc)
                Pc.append(pc * 1e5)  # convert bar to Pa
                wc.append(w)
            else:
                raise ValueError(f"Component '{comp}' not found in data dictionary.")
        return np.array(Tc), np.array(Pc), np.array(wc)
    
    def get_molecular_weights(self):
        Mw = []
        for comp in self.components:
            if comp in self.Mw_data:
                Mw.append(self.Mw_data[comp])
            else:
                raise ValueError(f"Molecular weight for component '{comp}' not found.")
        return np.array(Mw)

# =============================================================================
# Dummy Antoine Class
# =============================================================================
class DummyAntoine:
    """
    Supplies the necessary thermodynamic properties for the mixture.
    Change the 'components' list and the vapor mole fractions 'y' as needed.
    You can also specify a uniform binary interaction parameter kij_value (default is 0.20)
    to calibrate the mixing rule.
    """
    def __init__(self, components, y, kij_value=0.020):
        comp_data = ComponentData(components)
        self.Tc, self.Pc, self.wc = comp_data.get_properties()
        self.Mw = comp_data.get_molecular_weights()  # Molecular weights (g/mol)
        self.Nc = len(components)
        self.y = np.array(y)  # Vapor mole fractions (should sum to 1)
        self.R = 8.314       # J/mol·K (Universal gas constant)
        self.omega = 0.07780 # Peng-Robinson constant
        self.psi = 0.45724   # Peng-Robinson constant
        # Operating pressure in Pascals – adjust as needed.
        self.P = 6.6328e+7    # Example: 2.0684e7 Pa (~203.9 bar)
        # Set kij uniformly for all pairs (calibrate as needed)
        self.kij = np.full((self.Nc, self.Nc), kij_value)

# =============================================================================
# EoS Mixture Class with Fator_Z Calculation
# =============================================================================
class EoS_mistura_phenom:
    def __init__(self, antoine, EoS):
        # Extract properties from the Antoine-like object.
        self.Tc = antoine.Tc
        self.w = antoine.wc
        self.Nc = antoine.Nc
        self.y = antoine.y
        self.Pc = antoine.Pc
        self.R = antoine.R
        self.P = antoine.P
        self.omega = antoine.omega
        self.psi = antoine.psi
        self.kij = antoine.kij
        self.EoS = EoS  # 'PR' for Peng-Robinson, 'SRK', etc.
        
    def parametros_EoS(self, T, x):
        """
        Calculates mixture parameters needed for the EOS.
        T: operating temperature in Kelvin.
        x: liquid-phase composition (assumed equal to vapor-phase composition here).
        """
        self.T = T
        self.x = x
        self.Tr = self.T / self.Tc  # Reduced temperatures
        
        # Calculate pure component parameters.
        self.ai = np.zeros(self.Nc)
        self.bi = np.zeros(self.Nc)
        if self.EoS == 'PR':
            kappai = 0.37464 + 1.54226 * self.w - 0.26992 * self.w**2
            alphai = (1 + kappai * (1 - np.sqrt(self.Tr)))**2
            for i in range(self.Nc):
                self.ai[i] = self.psi * self.R**2 * (alphai[i] * self.Tc[i]**2) / self.Pc[i]
                self.bi[i] = self.omega * self.R * self.Tc[i] / self.Pc[i]
        elif self.EoS == 'SRK':
            kappai = 0.480 + 1.574 * self.w - 0.176 * self.w**2
            alphai = (1 + kappai * (1 - np.sqrt(self.Tr)))**2
            for i in range(self.Nc):
                self.ai[i] = self.psi * self.R**2 * (alphai[i] * self.Tc[i]**2) / self.Pc[i]
                self.bi[i] = self.omega * self.R * self.Tc[i] / self.Pc[i]
        else:
            for i in range(self.Nc):
                self.ai[i] = self.psi * self.R**2 * (self.Tr[i]**(-0.5) * self.Tc[i]**2) / self.Pc[i]
                self.bi[i] = self.omega * self.R * self.Tc[i] / self.Pc[i]
        
        # Compute mixture parameters using classical mixing rules.
        self.aij = np.zeros((self.Nc, self.Nc))
        for i in range(self.Nc):
            for j in range(self.Nc):
                self.aij[i, j] = (1 - self.kij[i, j]) * np.sqrt(self.ai[i] * self.ai[j])
        self.av = np.sum(np.outer(self.y, self.y) * self.aij)
        self.bv = np.sum(self.y * self.bi)
        
        # Define beta and q such that A = q * beta.
        self.betav = self.bv * self.P / (self.R * self.T)
        self.qv = self.av / (self.bv * self.R * self.T)
        # Thus, A = a_mix * P/(R^2 T^2) = qv * betav.
        
        # For liquid composition, if assumed equal to vapor:
        self.ql = self.qv
        self.betal = self.betav
        
        return self.betav, self.betal, self.bv, self.ql, self.qv
    
    def Fator_Z(self):
        """
        Calculates the compressibility factor (Z) for vapor and liquid phases 
        by solving the Peng-Robinson cubic equation:
        
        Z^3 - (1 - beta) Z^2 + (A - 3 beta^2 - 2 beta) Z - (A beta - beta^2 - beta^3) = 0,
        
        where beta = b_mix P/(RT) and A = a_mix P/(R^2T^2).
        """
        A = self.qv * self.betav  # A = a_mix P/(R^2 T^2)
        c3 = 1.0
        c2 = -(1 - self.betav)
        c1 = A - 3 * self.betav**2 - 2 * self.betav
        c0 = -(A * self.betav - self.betav**2 - self.betav**3)
        coef = [c3, c2, c1, c0]
        roots = np.roots(coef)
        real_roots = np.real(roots[np.isreal(roots)])
        if len(real_roots) > 0:
            Zv = np.max(real_roots)  # Vapor Z: maximum real root
            Zl = np.min(real_roots)  # Liquid Z: minimum real root
        else:
            Zv = np.nan
            Zl = np.nan
        return Zv, Zl

# =============================================================================
# Main Execution Section
# =============================================================================
if __name__ == '__main__':
    # Updated list including C6:
    components = ['Methane', 'Ethane', 'Propane', 'nButane', 'iButane', 
                  'nPentane', 'iPentane', 'C7+', 'C6', 'CO2', 'N2', 'H2S']
    # Suppose your original mole fractions (for 10 components) were given, and you want to add C6.
    # For instance, you might choose:
    # (These numbers are an example. They must be adjusted so that the total sums to 1.)
    y_original = [0.6632, 0.0387, 0.0283, 0.013, 0.0066, 0.0060, 0.0729, 0.1016, 0.003, 0.0504]  # 10 components without C6 and H2S
    # Now, assume you want to assign a mole fraction of 0.02 for C6 and 0.0504 for H2S.
    # Then the desired total for the original 10 becomes 1 - (0.02 + 0.0504) = 0.9296.
    # Compute the scaling factor:
    f = 0.9296 / sum(y_original)  # Scale the original 10 mole fractions
    y_scaled = [yi * f for yi in y_original]
    # Now define the complete mole fractions list:
    # Order must match the components list:
    # ['Methane', 'Ethane', 'Propane', 'nButane', 'iButane', 'nPentane', 'iPentane', 'C7+', 'C6', 'CO2', 'N2', 'H2S']
    y = y_scaled + [0.02, 0.0504]  # Append C6 (0.02) and H2S (0.0504)
    
    print("New mole fractions (should sum to 1):", y)
    print("Sum:", sum(y))
    
    # Instantiate the DummyAntoine object with the updated lists.
    antoine = DummyAntoine(components, y, kij_value=0.020)
    eos_mix = EoS_mistura_phenom(antoine, 'PR')
    
    T_system = 336.483  # Operating temperature in Kelvin
    x_initial = antoine.y  # Assume liquid equals vapor composition
    
    eos_mix.parametros_EoS(T_system, x_initial)
    Z_vapor, Z_liquid = eos_mix.Fator_Z()
    
    Mw_data = {
        'Methane': 16.04,
        'Ethane': 30.07,
        'Propane': 44.10,
        'nButane': 58.12,
        'iButane': 58.12,
        'nPentane': 72.15,
        'iPentane': 72.15,
        'C7+': 98.0,
        'C6': 86.18,
        'CO2': 44.01,
        'N2': 28.01,
        'H2S': 34.08
    }
    Mw = np.array([Mw_data[c] for c in components])
    M_app = np.sum(antoine.y * Mw)
    SG = M_app / 28.96
    
    T_pc = np.sum(antoine.y * antoine.Tc)
    P_pc = np.sum(antoine.y * antoine.Pc)
    T_r = T_system / T_pc
    P_r = antoine.P / P_pc
    
    print("Components:", components)
    print("Operating Temperature (K):", T_system)
    print("Operating Pressure (Pa):", antoine.P)
    print("Pseudo-critical Temperature (K):", T_pc)
    print("Pseudo-critical Pressure (Pa):", P_pc)
    print("Reduced Temperature (T_r):", T_r)
    print("Reduced Pressure (P_r):", P_r)
    print("Vapor compressibility factor, Z_vapor =", Z_vapor)
    print("Liquid compressibility factor, Z_liquid =", Z_liquid)
    print("Apparent Molecular Weight (g/mol):", M_app)
    print("Specific Gravity (SG):", SG)
